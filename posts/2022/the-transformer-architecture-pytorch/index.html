
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta property="og:title" content="Architecture du transformer et implémentation avec Pytorch (Partie I)" />
  
<meta property="og:type" content="website" />
  
<meta property="og:url" content="https://godwinh19.github.io/posts/2022/the-transformer-architecture-pytorch/" />
  
<meta property="og:description" content="Qu’est ce qu’un transformer ?: Un modèle de transformer est un réseau neuronal qui apprend le contexte et donc le sens en suivant les relations dans les données séquentielles comme les mots de cett..." />
  
<meta property="og:image" content="https://godwinh19.github.io/_static/ico.PNG" />
  
<meta property="og:image:alt" content="Architecture du transformer et implémentation avec Pytorch (Partie I)" />
  
    <title>Architecture du transformer et implémentation avec Pytorch (Partie I) &#8212; Godwin H  documentation</title>
    
    <link href="../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
  
    
    <link rel="stylesheet"
      href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
    <link rel="preload" as="font" type="font/woff2" crossorigin
      href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
    <link rel="preload" as="font" type="font/woff2" crossorigin
      href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">
  
    
      
  
    
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/pydata-sphinx-theme.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
    <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">
  
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <link rel="shortcut icon" href="../../../_static/ico.PNG"/>
    <link rel="author" title="About these documents" href="../../../about/" />
    <link rel="index" title="Index" href="../../../genindex/" />
    <link rel="search" title="Search" href="../../../search/" /> 
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
     
<link
  rel="alternate"
  type="application/atom+xml"
  href="../../../blog/atom.xml"
  title="Godwin H"
/>
 
<style type="text/css">
  ul.ablog-archive {
    list-style: none;
    overflow: auto;
    margin-left: 0px;
  }
  ul.ablog-archive li {
    float: left;
    margin-right: 5px;
    font-size: 80%;
  }
  ul.postlist a {
    font-style: italic;
  }
  ul.postlist-style-disc {
    list-style-type: disc;
  }
  ul.postlist-style-none {
    list-style-type: none;
  }
  ul.postlist-style-circle {
    list-style-type: circle;
  }
</style>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    
<a class="navbar-brand" href="../../../">
<p class="title">Godwin H</p>
</a>

    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../about/">
  About me
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../blog/">
  Blog
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <form class="bd-search d-flex align-items-center" action="../../../search/" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this site..." aria-label="Search this site..." autocomplete="off" >
</form>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/Godwinh19/" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/GodwinHoudji" rel="noopener" target="_blank" title="Twitter"><span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items">  
<h2>
   <i class="fa fa-calendar"></i>
  26 mai 2022 
</h2>

<ul>
      
<li id="category">
  <span
    ><i class="fa-fw fa fa-folder-open"></i></span
  >
   
  <a href="../../../blog/category/deep-learning/">Deep Learning</a>  
</li>
 
<li id="tags">
  <span
    ><i class="fa-fw fa fa-tags"></i> </span
  >
   
  <a href="../../../blog/tag/deep-learning/">deep learning</a>   
  <a href="../../../blog/tag/nlp/">nlp</a>   
  <a href="../../../blog/tag/transformers/">transformers</a>   
  <a href="../../../blog/tag/attention/">attention</a>  
</li>
 
<li id="comments">
  <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = "godwinh19"; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
      var s = document.createElement("script");
      s.async = true;
      s.type = "text/javascript";
      s.src = "//" + disqus_shortname + ".disqus.com/count.js";
      (
        document.getElementsByTagName("HEAD")[0] ||
        document.getElementsByTagName("BODY")[0]
      ).appendChild(s);
    })();
  </script>
  <i class="fa-fw fa fa-comments"></i>
  <a
    href="#disqus_thread"
    data-disqus-identifier="/posts/2022/the-transformer-architecture-pytorch/"
  >
    </a
  >
</li>

</ul>

<h3>
  <a href="../../../blog/">Recent Posts</a>
</h3>
<ul>
   
  <li>
    <a href="../bert-classification-for-research-papers/"
      >22 mars - Bert Classification For Research Papers</a
    >
  </li>
  
</ul>

<h3>
  <a href="../../../blog/archive/">Archives</a>
</h3>
<ul>
   
  <li>
    <a href="../../../blog/2022/">2022 (2)</a>
  </li>
   
</ul>

              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   Architecture du transformer et implémentation avec Pytorch (Partie I)
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#self-attention-ou-auto-attention">
     Self-Attention ou Auto-Attention
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#multi-head-attention-attention-a-tetes-multiples">
     Multi-head attention: attention à têtes multiples
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-feed-forward-layer-ou-couche-a-propagation-avant">
     The Feed-Forward Layer ou couche à propagation avant
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#layer-normalisation-ou-normalisation-de-couche">
     Layer Normalisation ou normalisation de couche
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#positional-embeddings-ou-encastrement-positionnels">
     Positional embeddings ou encastrement positionnels
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#endnote">
     Endnote
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ressources">
   Ressources
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              

              <div>
                 <div class="tex2jax_ignore mathjax_ignore section" id="architecture-du-transformer-et-implementation-avec-pytorch-partie-i">
<h1>Architecture du transformer et implémentation avec Pytorch (Partie I)<a class="headerlink" href="#architecture-du-transformer-et-implementation-avec-pytorch-partie-i" title="Permalink to this headline">¶</a></h1>
<p><strong>Qu’est ce qu’un transformer ?:</strong>
Un modèle de transformer est un réseau neuronal qui apprend le contexte et donc le sens en suivant les relations dans les données séquentielles comme les mots de cette phrase. Dans la version originale de leur papier <a class="reference external" href="https://arxiv.org/abs/1706.03762">Attention Is All You Need</a>, les auteurs définisse le transformer comme une nouvelle architecture de réseau simple basée uniquement sur les mécanismes d’attention, exemptée entièrement de récurrence ou de convolution.</p>
<p><strong>Applications</strong></p>
<p>Les transformers constituent ce qu’on appelle maintenant la fondation des modèles de deep learning. Ils sont utilisés entre autres pour les tâches comme:</p>
<ul class="simple">
<li><p>Question réponse</p></li>
<li><p>Classification de texte</p></li>
<li><p>Extraction d’information</p></li>
<li><p>Reconnaissance d’objets</p></li>
<li><p>Analyse de sentiment</p></li>
<li><p>Légende des images</p></li>
<li><p>etc</p></li>
</ul>
<p>Le transformer est constitué de deux grandes parties que sont l’encodeur et le décodeur.
<strong>L’encodeur</strong> prend la séquence d’entrée et crée une représentation contextuelle (également appelée contexte) de celle-ci. Le <strong>décodeur</strong> prend cette représentation contextuelle en entrée et génère la séquence de sortie. Le processus peut être résumé comme suit:</p>
<p><img alt="process" src="https://latex.codecogs.com/svg.image?%5Cmathbf%7BX%7D&amp;space%3B%5CLongrightarrow&amp;space%3B%5Cmathbf%7BEncodeur%7D&amp;space%3B%5CLongrightarrow&amp;space%3B%5Cmathbf%7Bcontexte%7D&amp;space%3B%5CLongrightarrow&amp;space%3B%5Cmathbf%7BDecodeur%7D&amp;space%3B%5CLongrightarrow&amp;space%3B%5Cmathbf%7BY%7D" /></p>
<p><strong>X</strong> constitue l’entrée et <strong>Y</strong> la sortie.</p>
<p>Dans cette première partie, nous allons suivre le processus bloc par bloc afin de construire notre propre encoder du tranformer. Commençons par le point le plus important: le <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">attention</span></code>.</p>
<div class="section" id="self-attention-ou-auto-attention">
<h2>Self-Attention ou Auto-Attention<a class="headerlink" href="#self-attention-ou-auto-attention" title="Permalink to this headline">¶</a></h2>
<p>Il existe plusieurs façons de mettre en œuvre une couche d’auto-attention, mais la plus courante est l’attention par produit scalaire, tirée de l’article présentant l’architecture du transformer Quatre étapes principales sont nécessaires pour mettre en œuvre ce mécanisme :</p>
<ul class="simple">
<li><p>Projection de chaque encastrement de jeton dans trois vecteurs appelés <code class="docutils literal notranslate"><span class="pre">key</span></code>,<code class="docutils literal notranslate"><span class="pre">query</span></code>,<code class="docutils literal notranslate"><span class="pre">value</span></code>.</p></li>
<li><p>Calculer les scores d’attention. Nous déterminons dans quelle mesure les vecteurs de <code class="docutils literal notranslate"><span class="pre">query</span></code> et de <code class="docutils literal notranslate"><span class="pre">key</span></code> sont liés les uns aux autres en utilisant une fonction de similarité. Comme son nom l’indique, la fonction de similarité pour l’attention par produit scalaire est le produit scalaire, calculé efficacement en utilisant la multiplication matricielle des incorporations. Les <code class="docutils literal notranslate"><span class="pre">query</span></code> et les <code class="docutils literal notranslate"><span class="pre">key</span></code> qui sont similaires auront un produit scalaire important, tandis que ceux qui n’ont pas beaucoup de points communs n’auront que peu ou pas de chevauchement. Les résultats de cette étape sont appelés les <strong>scores d’attention</strong>, et pour une séquence de <img alt="math" src="https://latex.codecogs.com/svg.image?n" /> tokens d’entrée, il existe une matrice <img alt="math" src="https://latex.codecogs.com/svg.image?n*n" /> correspondante de scores d’attention.</p></li>
<li><p>Calculer les poids d’attention. Les produits scalaires peuvent en général produire des nombres arbitrairement grands, ce qui peut déstabiliser le processus de formation. Pour y remédier, les scores d’attention sont d’abord multipliés par un facteur d’échelle afin de normaliser leur variance, puis normalisés à l’aide d’un softmax afin de s’assurer que la somme de toutes les valeurs des colonnes est égale à 1. Le résultat des <img alt="nbyn" src="https://latex.codecogs.com/svg.image?n*n" /> matrice contient maintenant tous les poids d’attention <img alt="math" src="https://latex.codecogs.com/svg.image?w_%7Bji%7D" /></p></li>
<li><p>Mise à jour de l’intégration des jetons. Une fois les poids d’attention calculés, nous les multiplions par le vecteur de valeurs (<code class="docutils literal notranslate"><span class="pre">value</span></code>) afin d’obtenir une représentation actualisée pour l’incorporation: <img alt="update weights" src="https://latex.codecogs.com/svg.image?x_i%27&amp;space%3B=&amp;space%3B%5Csum_%7Bj%7Dw_%7Bji%7Dv_j" /></p></li>
</ul>
<p>En premier temps, nous allons extraire les tokens de notre texte:
<em>PS:</em> Pour plus de facilité nous travaillerons avec les hyper-paramètres utilisés dans l’architecture <strong>BERT</strong>. Retrouvez le model de Bert sur huggingface <a class="reference external" href="https://huggingface.co/bert-base-uncased">ici</a> et le papier <a class="reference external" href="https://arxiv.org/abs/1810.04805">ici</a></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">transformers</span> <span class="kn">import</span> <span class="n">AutoTokenizer</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model_ckpt</span> <span class="o">=</span> <span class="s2">&quot;bert-base-uncased&quot;</span>
<span class="n">tokenizer</span> <span class="o">=</span> <span class="n">AutoTokenizer</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">model_ckpt</span><span class="p">)</span>
<span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;learn power of &quot;&quot;time flies like an arrow&quot;</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">inputs</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">return_tensors</span><span class="o">=</span><span class="s2">&quot;pt&quot;</span><span class="p">,</span> <span class="n">add_special_tokens</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">inputs</span><span class="o">.</span><span class="n">input_ids</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tensor([[ 2051, 10029,  2066,  2019,  8612]])
</pre></div>
</div>
<p>Nous avons ajouté le <code class="docutils literal notranslate"><span class="pre">add_special_tokens=False</span></code> pour ignorer les tokens spéciales comme [CLS] et [SEP].
Ensuite, nous devons créer des incorporations denses. Dans ce contexte, dense signifie que chaque entrée dans les incorporations contient une valeur non nulle. Ces incorporations sont des vecteurs zéros avec une seule valeur de 1 à une position donnée: <code class="docutils literal notranslate"><span class="pre">one</span> <span class="pre">hot</span> <span class="pre">encoding</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="nn">transformers</span> <span class="kn">import</span> <span class="n">AutoConfig</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">AutoConfig</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">model_ckpt</span><span class="p">)</span>
<span class="n">config</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BertConfig {
  &quot;architectures&quot;: [
    &quot;BertForMaskedLM&quot;
  ],
  &quot;attention_probs_dropout_prob&quot;: 0.1,
  &quot;classifier_dropout&quot;: null,
  &quot;gradient_checkpointing&quot;: false,
  &quot;hidden_act&quot;: &quot;gelu&quot;,
  &quot;hidden_dropout_prob&quot;: 0.1,
  &quot;hidden_size&quot;: 768,
  &quot;initializer_range&quot;: 0.02,
  &quot;intermediate_size&quot;: 3072,
  &quot;layer_norm_eps&quot;: 1e-12,
  &quot;max_position_embeddings&quot;: 512,
  &quot;model_type&quot;: &quot;bert&quot;,
  &quot;num_attention_heads&quot;: 12,
  &quot;num_hidden_layers&quot;: 12,
  &quot;pad_token_id&quot;: 0,
  &quot;position_embedding_type&quot;: &quot;absolute&quot;,
  &quot;transformers_version&quot;: &quot;4.11.3&quot;,
  &quot;type_vocab_size&quot;: 2,
  &quot;use_cache&quot;: true,
  &quot;vocab_size&quot;: 30522
}
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">token_emb</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">vocab_size</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">)</span>
<span class="n">token_emb</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Embedding(30522, 768)
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">inputs_embeds</span> <span class="o">=</span> <span class="n">token_emb</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">input_ids</span><span class="p">)</span>
<span class="n">inputs_embeds</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>torch.Size([1, 5, 768])
</pre></div>
</div>
<p>Pour l’instant, nous allons remettre à plus tard l’encodage de position et passer à la création des clés, requêtes et valeurs en utilisant le produit scalaire comme fonction de similarité.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>

<span class="n">query</span> <span class="o">=</span> <span class="n">key</span> <span class="o">=</span> <span class="n">value</span> <span class="o">=</span> <span class="n">inputs_embeds</span>
<span class="n">dim_k</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">scores</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">bmm</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dim_k</span><span class="p">)</span>
<span class="n">scores</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>torch.Size([1, 5, 5])
</pre></div>
</div>
<p>La division par <img alt="math" src="https://latex.codecogs.com/svg.image?%5Csqrt%7Bd_k%7D" /> du score permet de ne pas avoir de grandes valeurs durant l’entraînement.
Par la suite, appliquons la fonction softmax qui va permettre d’avoir une somme des scores égale à 1.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>

<span class="n">weights</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tensor([[1., 1., 1., 1., 1.]], grad_fn=&lt;SumBackward1&gt;)
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">attn_outputs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">bmm</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="n">attn_outputs</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>torch.Size([1, 5, 768])
</pre></div>
</div>
<p>Nous venons de finir une implémentation simplifiée d’auto-attention. Nous rappelons que tous le processus est juste une multiplication matricielle et une fonction softmax.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">scaled_dot_product_attention</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">dim_k</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">bmm</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dim_k</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">bmm</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>Le self attention est finalement calculé comme suit:</p>
<p><img alt="math" src="https://latex.codecogs.com/svg.image?Attention(Q,K,V)&amp;space%3B=&amp;space%3Bsoftmax(%5Cfrac%7BQK%5ET%7D%7B%5Csqrt%7Bd_k%7D%7D)V" /></p>
</div>
<div class="section" id="multi-head-attention-attention-a-tetes-multiples">
<h2>Multi-head attention: attention à têtes multiples<a class="headerlink" href="#multi-head-attention-attention-a-tetes-multiples" title="Permalink to this headline">¶</a></h2>
<p>En pratique, la couche d’auto-attention applique trois transformations linéaires indépendantes à chaque incorporation pour générer les vecteurs de requête, de clé et de valeur. Ces transformations projettent les enchâssements et chaque projection porte son propre ensemble de paramètres apprenables, ce qui permet à la couche d’auto-attention de se concentrer sur différents aspects sémantiques de la séquence.</p>
<p>Il s’avère également avantageux de disposer de plusieurs ensembles de projections linéaires, chacun représentant une tête d’attention.Mais pourquoi avons-nous besoin de plus d’une tête d’attention ? La raison est que la softmax d’une tête a tendance à se concentrer sur un seul aspect de la similarité. Le fait d’avoir plusieurs têtes permet au modèle de se concentrer sur plusieurs aspects à la fois. Par exemple, une tête peut se concentrer sur l’interaction sujet-verbe, tandis qu’une autre trouve des adjectifs proches. Il est évident que nous n’intégrons pas ces relations dans le modèle et qu’elles sont entièrement apprises à partir des données. Une analogie peut être faite avec les modèles de vision par ordinateur. Nous avons les filtres des réseaux neuronaux convolutifs, où un filtre peut être responsable de la détection des visages et un autre de la recherche des roues de voitures dans les images.</p>
<p>Commençons d’abord par implémenter une seule attention à tête:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AttentionHead</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">embed_dim</span><span class="p">,</span> <span class="n">head_dim</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">embed_dim</span><span class="p">,</span> <span class="n">head_dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">embed_dim</span><span class="p">,</span> <span class="n">head_dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">embed_dim</span><span class="p">,</span> <span class="n">head_dim</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidden_state</span><span class="p">):</span>
        <span class="n">attn_outputs</span> <span class="o">=</span> <span class="n">scaled_dot_product_attention</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">(</span><span class="n">hidden_state</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">hidden_state</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">(</span><span class="n">hidden_state</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">attn_outputs</span>
</pre></div>
</div>
<p>En pratique, on choisit la valeur de <code class="docutils literal notranslate"><span class="pre">embed_dim</span></code> pour qu’elle soit un multiple de <code class="docutils literal notranslate"><span class="pre">head_dim</span></code>. En prenant l’exemple de l’architecture BERT, la dimension de l’entête est de 768/12 = 64.</p>
<p>Maintenant que nous avons une seule tête d’attention, nous pouvons concaténer les sorties de chacune d’elles pour mettre en œuvre la couche d’attention multi-têtes complète :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MultiHeadAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">embed_dim</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span>
        <span class="n">num_heads</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">num_attention_heads</span>
        <span class="n">head_dim</span> <span class="o">=</span> <span class="n">embed_dim</span> <span class="o">//</span> <span class="n">num_heads</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">heads</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ModuleList</span><span class="p">(</span>
            <span class="p">[</span><span class="n">AttentionHead</span><span class="p">(</span><span class="n">embed_dim</span><span class="p">,</span> <span class="n">head_dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_heads</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="c1"># A la sortie de cette couche, nous avons un vecteur [batch, embed_dim, head_dim]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_linear</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">embed_dim</span><span class="p">,</span> <span class="n">embed_dim</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hidden_state</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">h</span><span class="p">(</span><span class="n">hidden_state</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">heads</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># la fonction cat permet de concatener les sorties de la couche d&#39;attention à </span>
        <span class="c1"># seule tête pour avoir un vecteur [batch, embed_dim, head_dim*num_heads]</span>
        <span class="c1"># head_dim*num_heads encore égal à embed_dim: entrée de la couche linéaire suivante.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_linear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
    
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">multihead_attn</span> <span class="o">=</span> <span class="n">MultiHeadAttention</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="n">attn_output</span> <span class="o">=</span> <span class="n">multihead_attn</span><span class="p">(</span><span class="n">inputs_embeds</span><span class="p">)</span>
<span class="n">attn_output</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>torch.Size([1, 5, 768])
</pre></div>
</div>
</div>
<div class="section" id="the-feed-forward-layer-ou-couche-a-propagation-avant">
<h2>The Feed-Forward Layer ou couche à propagation avant<a class="headerlink" href="#the-feed-forward-layer-ou-couche-a-propagation-avant" title="Permalink to this headline">¶</a></h2>
<p>Cette sous-couche dans le transformer est un simple réseau neuronal entièrement connecté à deux couches, mais avec une particularité : au lieu de traiter la séquence entière d’incorporations comme un vecteur unique, elle traite chaque incorporation indépendamment. C’est la raison pour laquelle cette couche est souvent appelée couche à propagation avant en fonction de la position.</p>
<p>Une règle empirique tirée de la littérature est que le <code class="docutils literal notranslate"><span class="pre">hidden_size</span></code> de la première couche doit être quatre fois supérieure à la taille des embeddings, et une fonction d’activation <code class="docutils literal notranslate"><span class="pre">GELU</span></code> est le plus souvent utilisée.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FeedForward</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">intermediate_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">intermediate_size</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gelu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">GELU</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_dropout_prob</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gelu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linear_1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">feed_forward</span> <span class="o">=</span> <span class="n">FeedForward</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="n">ff_outputs</span> <span class="o">=</span> <span class="n">feed_forward</span><span class="p">(</span><span class="n">attn_output</span><span class="p">)</span>
<span class="n">ff_outputs</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>torch.Size([1, 5, 768])
</pre></div>
</div>
<p>Nous avons maintenant tous les ingrédients pour créer une couche d’encodeur du transformer ! La seule décision qui reste à prendre est de savoir où placer les connexions de saut et la normalisation de la couche.</p>
</div>
<div class="section" id="layer-normalisation-ou-normalisation-de-couche">
<h2>Layer Normalisation ou normalisation de couche<a class="headerlink" href="#layer-normalisation-ou-normalisation-de-couche" title="Permalink to this headline">¶</a></h2>
<p>Le transformer normalise chaque entrée du lot pour qu’elle ait une moyenne nulle et une variance unitaire. Les connexions de saut passent un tenseur (non traité) à la couche suivante du modèle et l’ajoute au tenseur traité. Dans la littérature, nous avons deux options possibles pour la normalisation:</p>
<ul class="simple">
<li><p>Normalisation post-couche: ici la normalisation est effectuée entre les connexions de saut. Cette disposition est délicate à former à partir de zéro car les gradients peuvent diverger. Pour cette raison, vous verrez souvent un concept connu sous le nom de <code class="docutils literal notranslate"><span class="pre">learning</span> <span class="pre">rate</span> <span class="pre">warm-up</span></code>, où le taux d’apprentissage est progressivement augmenté d’une petite valeur à une valeur maximale pendant l’entraînement.</p></li>
<li><p>Normalisation de la pré-couche: Il s’agit de la disposition la plus courante trouvée dans la littérature; elle place la normalisation de couche dans la portée des connexions de saut. Elle tend à être beaucoup plus stable pendant l’apprentissage et ne nécessite généralement pas l’usage du <code class="docutils literal notranslate"><span class="pre">learning</span> <span class="pre">rate</span> <span class="pre">warm-up</span></code>.</p></li>
</ul>
<p>Nous allons utiliser la seconde option et écrire l’encodeur de notre transformer de la façon suivante:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TransformerEncoderLayer</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">LayerNorm</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">LayerNorm</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attention</span> <span class="o">=</span> <span class="n">MultiHeadAttention</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feed_forward</span> <span class="o">=</span> <span class="n">FeedForward</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># 1- layer normalisation</span>
        <span class="n">hidden_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_norm_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># 2- apply attention with skip connection</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attention</span><span class="p">(</span><span class="n">hidden_state</span><span class="p">)</span>
        <span class="c1"># 3- feed forward layer with skip connection</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">feed_forward</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_norm_2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">encoder_layer</span> <span class="o">=</span> <span class="n">TransformerEncoderLayer</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="n">inputs_embeds</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">encoder_layer</span><span class="p">(</span><span class="n">inputs_embeds</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(torch.Size([1, 5, 768]), torch.Size([1, 5, 768]))
</pre></div>
</div>
<p>Actuellement les couches de l’encodeur sont invariants par rapport à la position des token. Nous allons ajouter cette nouvelle information en utilisant le <code class="docutils literal notranslate"><span class="pre">positional</span> <span class="pre">embeddings</span></code></p>
</div>
<div class="section" id="positional-embeddings-ou-encastrement-positionnels">
<h2>Positional embeddings ou encastrement positionnels<a class="headerlink" href="#positional-embeddings-ou-encastrement-positionnels" title="Permalink to this headline">¶</a></h2>
<p>Son but est de permettre au modèle d’apprendre la formation des tokens. Etant donné qu’une phrase n’a de sens que si les ordres des mots sont respectés. Cette couche apprend cette constitution des mots.</p>
<p>Créons un module Embeddings personnalisé qui combine une couche d’embeddings de tokens qui projette les <code class="docutils literal notranslate"><span class="pre">input_ids</span></code> au <em>hidden state dense</em> avec l’embedding positionnel qui fait la même chose pour les <code class="docutils literal notranslate"><span class="pre">position_ids</span></code>.
Dans la configuration de <strong>BERT</strong> par exemple, la taille maximale d’un paragraphe pris en compte est de 512, ce qui veut dire que nous allons fixé comme position maximale d’un token à 512.
L’incorporation résultante est simplement la somme des deux incorporations :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Embeddings</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token_embeddings</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">vocab_size</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position_embeddings</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">max_position_embeddings</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">layer_norm</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">LayerNorm</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_ids</span><span class="p">):</span>
        <span class="c1"># Positions ids for the inputs</span>
        <span class="n">seq_length</span> <span class="o">=</span> <span class="n">input_ids</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">positions_ids</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">seq_length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Now we create position and token embeddings</span>
        <span class="n">token_embeddings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_embeddings</span><span class="p">(</span><span class="n">input_ids</span><span class="p">)</span>
        <span class="n">position_embeddings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_embeddings</span><span class="p">(</span><span class="n">positions_ids</span><span class="p">)</span>
        
        <span class="c1"># token combination</span>
        <span class="n">embeddings</span> <span class="o">=</span> <span class="n">token_embeddings</span> <span class="o">+</span> <span class="n">position_embeddings</span>
        <span class="n">embeddings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer_norm</span><span class="p">(</span><span class="n">embeddings</span><span class="p">)</span>
        <span class="n">embeddings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">embeddings</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">embeddings</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">embedding_layer</span> <span class="o">=</span> <span class="n">Embeddings</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="n">embedding_layer</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">input_ids</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>torch.Size([1, 5, 768])
</pre></div>
</div>
<p>Comprendre plus sur le positional embedding <a class="reference external" href="https://www.youtube.com/watch?v=dichIcUZfOw">ici</a></p>
<p>Combinons ces différentes étapes pour construire la couche d’encodage.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TransformerEncoder</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">Embeddings</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layers</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ModuleList</span><span class="p">([</span><span class="n">TransformerEncoderLayer</span><span class="p">(</span><span class="n">config</span><span class="p">)</span> 
                                     <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">num_hidden_layers</span><span class="p">)])</span>
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">layer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">encoder</span> <span class="o">=</span> <span class="n">TransformerEncoder</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="n">encoder</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">input_ids</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>torch.Size([1, 5, 768])
</pre></div>
</div>
<p>A cette étape, nous avons l’état caché de chaque token. Un grand avantage des modèles de transformer est qu’il peuvent être divisé en deux parties:</p>
<ul class="simple">
<li><p>en un corps indépendant de la tâche et</p></li>
<li><p>une tête spécifique à la tâche.</p></li>
</ul>
<p>Notre encodeur étant prêt à l’utilisation, ajoutons une tête de couche qui sera utilisé pour la classification.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TransformerForSequenceClassification</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">TransformerEncoder</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_dropout_prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">num_labels</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">x</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">config</span><span class="o">.</span><span class="n">num_labels</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">encoder_classifier</span> <span class="o">=</span> <span class="n">TransformerForSequenceClassification</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="n">encoder_classifier</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">input_ids</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>torch.Size([1, 3])
</pre></div>
</div>
<p>Nous avons défini pour notre tâche de classification <em>3 catégories</em>, les données sont envoyées vers la sous couche de classification après passage de l’encodeur et un dropout appliqué.</p>
<p>Ceci marque la fin l’encodeur !!.</p>
</div>
<div class="section" id="endnote">
<h2>Endnote<a class="headerlink" href="#endnote" title="Permalink to this headline">¶</a></h2>
<p>Le notebook est disponible <a class="reference external" href="https://github.com/Godwinh19/ds-portfolio/blob/main/transformer_architecture.ipynb">ici</a>.
Cheers ☕!</p>
</div>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="ressources">
<h1>Ressources<a class="headerlink" href="#ressources" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p>Natural Language Processing with Transformers <a class="reference external" href="https://github.com/nlp-with-transformers/notebooks">github</a></p></li>
<li><p>Natural Language Processing with Transformers <a class="reference external" href="https://www.oreilly.com/library/view/natural-language-processing/9781098103231/">the book</a></p></li>
<li><p>Attention is all you need: <a class="reference external" href="https://arxiv.org/abs/1706.03762">papier</a></p></li>
<li><p>The annoted transformer, par Guillaume Klein et al, <a class="reference external" href="http://nlp.seas.harvard.edu/2018/04/03/attention.html">ici</a></p></li>
<li><p>The Illustrated Transformer par Jay Alammar <a class="reference external" href="https://jalammar.github.io/illustrated-transformer/">ici</a></p></li>
<li><p><a class="reference external" href="https://medium.com/nerd-for-tech/nlp-theory-and-code-encoder-decoder-models-part-11-30-e686bcb61dc7">NLP Theory and Code: Encoder-Decoder Models</a></p></li>
</ul>
</div>

<div class="section">
    

<div class="section">
  <span style="float: left">
     
    <a href="../bert-classification-for-research-papers/">
      <i class="fa fa-arrow-circle-left"></i> Bert Classification For Research Papers
    </a>
    
  </span>
  <span>&nbsp;</span>
  <span style="float: right">
    
  </span>
</div>
  
  <div class="section">
    <h2>Comments</h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname = "godwinh19";
      var disqus_identifier = "/posts/2022/the-transformer-architecture-pytorch/";
      var disqus_title = "Architecture du transformer et implémentation avec Pytorch (Partie I)";
      var disqus_url = "https://godwinh19.github.io/posts/2022/the-transformer-architecture-pytorch";

      (function () {
        var dsq = document.createElement("script");
        dsq.type = "text/javascript";
        dsq.async = true;
        dsq.src = "//" + disqus_shortname + ".disqus.com/embed.js";
        (
          document.getElementsByTagName("head")[0] ||
          document.getElementsByTagName("body")[0]
        ).appendChild(dsq);
      })();
    </script>
    <noscript
      >Please enable JavaScript to view the
      <a href="https://disqus.com/?ref_noscript"
        >comments powered by Disqus.</a
      ></noscript
    >
    <a href="https://disqus.com" class="dsq-brlink"
      >comments powered by <span class="logo-disqus">Disqus</span></a
    >
  </div>
  
</div>

              </div>
              
<!-- Add a comment box underneath the page's content -->

              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          

      </div>
    </div>
  
    <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2022, Godwin H.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.4.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>